{
  "name": "Lipengcheng1995.GitHub.com",
  "tagline": "李鹏程的博客",
  "body": "# 数据库复习\r\n\r\n## 第一章、绪论\r\n\r\n### 概念比较多\r\n\r\n### 1.1数据库系统概述\r\n\r\n#### 数据库基本概念\r\n\r\n> #### 1.数据：\r\n>\r\n> > 数据库中的基本对象，是描述事物的符号\r\n>\r\n> #### 2.数据库\r\n>\r\n> > **长期存贮**在计算机中，**有组织的**，**可共享的**大量数据的集合\r\n>\r\n> #### 3.数据库管理系统（DBMS）\r\n>\r\n> > 用户与操作系统之间的一层软件，用于**科学组织存储数据，高效获取和维护数据**\r\n> >\r\n> > > *sql server*属于数据库管理系统\r\n>\r\n> #### 4.数据库系统（DBS）\r\n>\r\n> > 计算机系统引入数据库后的系统\r\n> >\r\n> > ##### 构成：\r\n> >\r\n> > > DB\r\n> > >\r\n> > > DBMS\r\n> > >\r\n> > > Application System\r\n> > >\r\n> > > DataBase Administrator(DBA)\r\n>\r\n> \r\n\r\n#### 数据管理技术的产生与发展\r\n\r\n> 1.人工管理阶段\r\n>\r\n> 2.文件系统阶段\r\n>\r\n> 3.数据库系统阶段\r\n\r\n#### 数据库系统的特点\r\n\r\n> 1.整体数据结构化\r\n>\r\n> 2.数据的共享性高、冗余度低、易于扩充\r\n>\r\n> 3.数据独立性高\r\n>\r\n> 4.数据由DBMS同一管理和控制\r\n\r\n### 1.2数据模型\r\n\r\n#### 分类\r\n\r\n**概念模型**\r\n\r\n**逻辑模型和物理模型**\r\n\r\n#### 组成要素\r\n\r\n*用来描述，组织，操作数据*\r\n\r\n> 1.数据结构【数据库组成对象及之间联系】\r\n>\r\n> 2.数据操作【查询、更新等】\r\n>\r\n> 3.完整性约束【制约依存规则】【保证数据的**正确性、有效性、相容性**】\r\n\r\n#### 概念模型和ER方法\r\n\r\n*概念模型*又叫信息模型，强调语义表达能力，主要用于**数据库设计**,是 **现实世界的第一层抽象**\r\n\r\n*逻辑模型和物理模型*按照计算机观点进行数据建模\r\n\r\n![概念模型和逻辑、物理模型](1-1.png)\r\n\r\n\r\n\r\n\r\n\r\n> 概念模型：\r\n>\r\n> *实体\r\n>\r\n> *属性\r\n>\r\n> *码：**唯一标识**实体的属性集\r\n>\r\n> *域\r\n>\r\n> *实体型：用实体名和属性名集合来抽象和刻画同类实体\r\n>\r\n> *实体集：同一类实际集合\r\n>\r\n> *联系：分为一对一，一对多，多对多\r\n\r\n##### ER模型\r\n\r\n![ER构成](1-2.png)\r\n\r\n**注意：**\r\n\r\n> 1.实体名、联系名不可以重复出现【不能由重名】\r\n>\r\n> 2.一个实体也不能多次出现【一个实体型就是一个矩形，不能画多了】\r\n\r\n#### 最常用的数据模型\r\n\r\n> 1.层次模型【非关系模型】\r\n>\r\n> > 树图展示\r\n> >\r\n> > 优点：简单高效\r\n> >\r\n> > 缺点：不通用，插入删除复杂，访问复杂\r\n>\r\n> 2.网状模型【非关系模型】\r\n>\r\n> 3.**关系模型**\r\n>\r\n> 4.面向对象模型\r\n>\r\n> 5.对象关系模型\t\r\n\r\n## 第二章、关系数据库\r\n\r\n### 1.关系数据结构\r\n\r\n> 候选码\r\n>\r\n> 主码\r\n>\r\n> 主属性：主码和候选码中的属性\r\n>\r\n> 非码属性\r\n>\r\n> 全码：关系中所有的属性都是*候选码*，称为主码\r\n>\r\n> > 个人意见：斜体部分是“候选码”而不是“主属性”，这个是由条件的，自己想\r\n>\r\n> 外部码：外码。不是本关系的码，而是其他关系【可以是本关系，自己与自己链接，班长的那个例子】的码\r\n>\r\n> ​\t外码不一定与对应的主码同名\r\n\r\n> 关系模式：\r\n> $$\r\n>\r\n> $$\r\n>\r\n> $$\r\n> R(U,D,DOM,F)\r\n> $$\r\n>\r\n> R:关系名\r\n>\r\n> U:属性名集合\r\n>\r\n> D：域集合\r\n>\r\n> DOM：U到D的映射\r\n>\r\n> F：U中属性之间的依赖集合\r\n>\r\n> ● 关系模式是型，是静态的、稳定的；\r\n>\r\n> ● 关系是关系模式的值，是动态的、随时间而变化的。 \r\n\r\n> 关系型数据库：\r\n>\r\n> ![完整性约束](2-1.png)\r\n>\r\n> 实体完整性：主属性不能为空\r\n>\r\n> 参照完整性：外码的取值\r\n>\r\n> > 要么为空\r\n> >\r\n> > 要么等于对应的属性的主码\r\n>\r\n> \r\n\r\n### 2.关系操作\r\n\r\n#### 集合运算$\\bigcup \\bigcap -$\r\n\r\n就是集合运算那些东西\r\n\r\n#### 专门的关系运算$\\sigma , \\pi , \\times ,\\div$\r\n\r\n\r\n$$\r\n\\sigma \\Sigma \\varsigma \\tau T \\upsilon \\Upsilon\r\n\r\n\\phi \\Phi \\varphi \\chi X \\psi \\Psi \\omega \\Omega\r\n$$\r\n*tips*： 在$\\sigma$【选择】和$\\pi$【投影】时，对应的列可以用数字代替，从左往右从1开始\r\n\r\n笛卡儿积产生的结果中有大量的**平庸元组**需要剔除\r\n\r\n#### 连接\r\n\r\n> 笛卡儿积 + 选择 = 条件连接\r\n\r\n> 分类：\r\n>\r\n> 1.等值连接\r\n>\r\n> ​\t$\\sigma$的条件是等号\r\n>\r\n> 2.自然连接\r\n>\r\n> ​\t连接时的条件必须是相同的，连接后去除重复属性列\r\n>\r\n> 3.外连接\r\n>\r\n> ​\t左外连接\r\n>\r\n> ​\t\t保留左侧要舍弃的元组\r\n>\r\n> ​\t右外联结\r\n>\r\n> ​\t\t保留右侧要舍弃的元组\t\r\n\r\n#### $\\div$\r\n\r\n> 象集：$Z_x1$在关系中取$x=x_1$的元组，并去除$x$列\r\n>\r\n> 除法：n给定关系R (X, Y) 和S(Y, Z)，X、Y、Z为属性组。¨元组在X上分量值x的象集Yx包含S在Y上投影的集合。\r\n\r\n\r\n\r\n### 3.关系完整性约束\r\n\r\n### 4.关系代数运算\r\n\r\n## 第三章、\t关系数据库标准语言SQL\r\n\r\n### 1.SQL特点\r\n\r\n！@#%！@%#￥@……@#￥%&……%#￥&%￥@￥！#￥！%！#￥……！#￥@#！%\r\n\r\n### 2.SQL使用——数据定义\r\n\r\n#### 模式\r\n\r\n~~~~sql\r\nCREATE SCHEMA \"模式名\" AUTHORIZATION “用户名”\r\n\r\nDROP SCHEMA \"模式名\" [CASCADE | RESTRICT]\r\n\r\n~~~~\r\n\r\n\r\n\r\n#### 基本表\r\n\r\n**表的建立**\r\n\r\n~~~~sql\r\nCREATE TABLE SC\r\n  (\t\tSno  CHAR(9), \r\n       \tCno  CHAR(4),  \r\n       \tGrade    SMALLINT,\r\n       \tPRIMARY KEY (Sno, Cno), /* 主码由两个属性构成， 必须作为表级完整性进行定义*/\r\n       \tFOREIGN KEY (Sno) REFERENCES Student(Sno),\r\n\t     /* 表级完整性约束条件，Sno是外码，被参照表是Student */\r\n      \tFOREIGN KEY (Cno) REFERENCES Course(Cno)\r\n\t     /* 表级完整性约束条件， Cno是外码，被参照表是Course*/\r\n  );\r\n\r\n~~~~\r\n\r\n![了解](3-1.png)\r\n\r\n**表的修改**\r\n\r\n~~~~sql\r\nALTER TABLE <表名>       \t\r\n    \t      [RENAME <旧表名> TO <新表名>];\r\n            [ADD <新列名> <数据类型>[完整性约束]]\r\n            [DROP <列名> ]\r\n    \t \t[ALTER COLUMN <列名> <数据类型>]\r\n            [ADD <完整性约束>]\r\n            [DROP <完整性约束名>]\r\n\r\n~~~~\r\n\r\n**表的删除**\r\n\r\n~~~~sql\r\nDROP  TABLE  <表名> ［RESTRICT| CASCADE］;\r\n\r\n~~~~\r\n\r\n\r\n\r\n#### 索引\r\n\r\n**索引分类**\r\n\r\n> 唯一索引：\r\n>\r\n> > 要求对应的列没有重复值\r\n>\r\n> 聚簇索引：\r\n>\r\n> > 改变对应的物理顺序\r\n> >\r\n> > 一个表只能有一个聚簇索引\r\n\r\n**索引建立与删除**\r\n\r\n~~~~sql\r\nCREATE  [UNIQUE] [CLUSTER]  INDEX <索引名>\r\n        ON <表名> (<列名>[<次序ASC|DESC>],[, <列名>[<次序>]]…)；\r\nDROP INDEX <表名.索引名>；\r\n~~~~\r\n\r\n\r\n\r\n#### 视图\r\n\r\n见视图专题\r\n\r\n### 3.SQL使用——数据查询\r\n\r\n**格式**\r\n\r\n~~~~sql\r\n SELECT [ALL|DISTINCT] <目标列表达式>\r\n                       [, <目标列表达式>]……\r\n    FROM  <表名或视图名>[,<表名或视图名>] …\r\n   [WHERE  <条件表达式>]\r\n   [GROUP  BY <列名1> [HAVING  <条件表达式>]]\r\n   [ORDER BY <列名2>[ASC|DESC]]；\r\n\r\n~~~~\r\n\r\n**查询分类**\r\n\r\n> 单表查询\r\n>\r\n> 多表查询\r\n>\r\n> > 注意：外连接`left out join on(关系)`,`right out join on (关系)`,`out join(关系)`\r\n>\r\n> 嵌套查询\r\n>\r\n> > 分类：\r\n> >\r\n> > 相关子查询\r\n> >\r\n> > 不相关子查询\r\n>\r\n> > 聚集函数\r\n>\r\n> > ANY,ALL\r\n>\r\n> > IN、EXISTS  **使用NOT EXISTS取反实现全称量词】**\r\n>\r\n> 集合查询【UNION INTERSECT EXCEPT】\r\n>\r\n> > 注意：\r\n> >\r\n> > > 1.要排序的话只能在最后排一次\r\n> > >\r\n> > > 2.操作的两部分对应的列要完全一致\r\n\r\n### 4.SQL使用——数据更新\r\n\r\n#### 插入\r\n\r\n````sql\r\nINSERT INTO <表名>[(<列名1>[,<列名2>]…)]\r\n\t VALUES( <常量1>[,<常量2>]…)；\r\n\r\n\r\nINSERT  INTO   Dept_age( Sdept, Avgage )  \r\n        SELECT Sdept, AVG(Sage)\r\n        FROM   Student\r\n        GROUP BY Sdept;\r\n\r\n````\r\n\r\n\r\n\r\n#### 修改\r\n\r\n````sql\r\n   UPDATE <表名> \r\n   SET  <列名>=<表达式> [,<列名>=<表达式>]…\r\n\r\n\r\n````\r\n\r\n#### 删除\r\n\r\n````sql\r\n DELETE  \r\n FROM    <表名>\r\n [WHERE  <条件>]；\r\n\r\n````\r\n\r\n\r\n\r\n\r\n\r\n### 5.SQL使用——视图专题\r\n\r\n#### 视图创建\r\n\r\n````sql\r\nCREATE VIEW <视图名>[(<列名>[,<列名>]…)]\r\n      AS 子查询\r\n      [WITH CHECK OPTION]；\r\n\r\n````\r\n\r\n\r\n\r\n#### 视图删除\r\n\r\n````sql\r\nDROP  VIEW  <视图名> [ CASCADE ] ； \r\n````\r\n\r\n#### 视图消解【重要】\r\n\r\n出错原因：消解是机械式的，可能会把聚集函数整到WHERE里面，造成错误\r\n\r\n\r\n\r\n#### 视图更新\r\n\r\n不可更新的视图：【了解】\r\n\r\n>•由多个表导出的视图，不可更新\r\n>\r\n>•视图的列来自表达式或常数，不可插入、修改、可删除\r\n>\r\n>•视图列是来自集函数，不可更新\r\n>\r\n>•视图定义中含有GROUP BY子句，不可更新\r\n>\r\n>•视图定义中含有DISTINCT短语，不可更新\r\n>\r\n>•视图定义中内层嵌套的表与导出该视图表相同，不可更新\r\n>\r\n>•在不允许更新的视图上定义的视图，不可更新\r\n\r\n\r\n\r\n## 第四章、数据库安全性\r\n\r\n### 用户识别\r\n\r\n> 用户标识\r\n>\r\n> 口令\r\n\r\n### 存取控制\r\n\r\n数据库安全**最重要**的一点就是确保只授权给有资格的用户访问数据库的权限\r\n\r\n#### 方法分类\r\n\r\n> 自主存取控制（DAC）\r\n>\r\n> ````sql\r\n> GRANT <权限> [, <权限> ]……\r\n>       [ ON <对象类型><对象名>]    \r\n>       TO <用户>[, <用户>]……\r\n>       [ WITH GRANT OPTION ]；\r\n>\r\n>\r\n>\r\n> REVOKE <权限> [, <权限> ]……\r\n>       [ ON <对象类型><对象名>]    \r\n>       FROM <用户>[, <用户>]……\r\n> ````\r\n>\r\n> ![权限](4-1.png)\r\n>\r\n> \r\n\r\n>强制存取控制(MAC)\r\n>\r\n>> 敏感度标记（Label）。敏感度标记被分为若干级别，例如：\r\n>>\r\n>> 绝密（TopSecret）\r\n>>\r\n>> 机密（Secret）\r\n>>\r\n>> 可信（Confidential）\r\n>>\r\n>> 公开（Public） 等\r\n>>\r\n>> ¨主体的敏感度标记称为许可证级别（ClearanceLevel）；\r\n>>\r\n>> ¨客体的敏感度标记称为密级（Classification Level）。\r\n\r\nDAC与MAC共同构成DBMS的安全机制\r\n\r\n¨实现MAC时要首先实现DAC，原因是：较高安全性级别提供的安全保护要包含较低级别的所有保护。\r\n\r\n## 第五章、数据库完整性\r\n\r\n#### 分类：\r\n\r\n> 实体完整性\r\n>\r\n> > primary key\r\n>\r\n> 参照完整性\r\n>\r\n> > ![用户自定义完整性](5-1.png)用户自定义完整性,限制的主要是**参照表**\r\n>\r\n> 用户自定义完整性\r\n>\r\n> > UNIQUE 、NOT NULL 、CHECK\r\n> >\r\n> > > CHECK的写法：就像sql查询中where条件里那么写就行了\r\n\r\n#### 触发器\r\n\r\n````sql\r\nCREATE  TRIGGER  <触发器名>\r\n\t\t     { BEFORE | AFTER }  <触发事件> ON <表名>\r\n\t\t      FOR  EACH  {  ROW | STATEMENT  }\r\n\t\t      [ WHEN <触发事件>]\r\n\t\t      <触发动作体>\r\n//SQL SERVER 以这个为主吧\r\nCREATE  TRIGGER   触发器名\r\n       ON  数据表名或视图名\r\n       AFTER | FOR| Instead of   INSERT 或 DELETE 或 UPDATE \r\nAS \r\nBEGIN  \r\n         --这里是要运行的SQL语句\r\nEND \r\nGO\r\n````\r\n\r\ndeleted表和inserted表\r\n\r\n![hehe](5-2.png)\r\n\r\n## 第六章、关系数据理论\r\n\r\n*引入*：关系模式在前边就已经提到过了，这里更多的讨论的是属性见关系，所以将关系模式表示为关系模式名R，属性名U,属性间关系F的三元组$R(U,F)$\r\n\r\n### 数据依赖的分类\r\n\r\n1.函数依赖【我们后边讨论的都是这个】\r\n\r\n2.多值依赖\r\n\r\n### 函数依赖的分类\r\n\r\n> 平凡函数依赖：（类似$AB \\rightarrow A$）\r\n>\r\n> 非平凡函数依赖：(类似$AB\\rightarrow C$)\r\n\r\n> 完全函数依赖：（类似：$AB \\rightarrow C$，但是$A \\nrightarrow C$而且$B \\nrightarrow C$）\r\n>\r\n> 部分函数依赖：(类似：$AB \\rightarrow C$,但是存在一个现象$A \\rightarrow C$)\r\n\r\n> 直接函数依赖：\r\n>\r\n> 传递函数依赖：($A\\rightarrow B , B\\rightarrow C  \\Longrightarrow A\\rightarrow C$)\r\n\r\n### 范式\r\n\r\n范式分类：\r\n\r\n![范式分类及范式之间的关系](6-1.png)\r\n\r\n### Armstrong公理系统\r\n\r\n*定位*：一套用于**模式分解算法**的**推理规则**\r\n\r\n自反律\r\n\r\n增广律\r\n\r\n传递律\r\n\r\n合并规则：\r\n\r\n分解规则：\r\n\r\n伪传递规则：$X\\rightarrow Y , YZ\\rightarrow A   \\Longrightarrow XZ\\rightarrow A$\r\n\r\n### 闭包\r\n\r\n![闭包的求解步骤](6-2.png)\r\n\r\n### 最小依赖集\r\n\r\n![最小依赖集的概念，要满足的条件](6-3.png)\r\n\r\n求最小依赖集的步骤：\r\n\r\n> 1.对右部的属性进行分解，保持右部只有一个属性\r\n>\r\n> 2.依次检查每一个公式是够必须的公式\r\n>\r\n> > 去掉此公式，然后求左侧属性的闭包，看能不能包括右侧属性\r\n>\r\n> 3.依次检查每个公式左侧的每一个属性是否此公式必须的属性\r\n>\r\n> > 一个一个的尝试去掉左侧的属性，【但是保留本公式】，看剩下的属性的闭包能否包含右侧的属性\r\n\r\n### 求解关系模式的候选码\r\n\r\n属性分类：\r\n\r\n![L,R,LR,N属性的定义及使用方法](6-4.png)\r\n\r\n### 模式分解\r\n\r\n要求：保证分解后的关系模式与原关系模式等价【。。。。】\r\n\r\n等价包括：\r\n\r\n> 分解具有“无损连接性” （Losslessjoin）\r\n>\r\n> 分解要“保持函数依赖” （Preservedependency）\r\n>\r\n> 分解既要“保持函数依赖”，又要具有“无损连接性”\r\n\r\n\r\n\r\n**分解为第三范式**：\r\n\r\n保留函数依赖：\r\n\r\n> F最小化 \r\n>\r\n> 一个推导式弄做一个模式\r\n\r\n保留函数依赖和无损联结：在上边的基础上加一个关系模式，里边由候选码关键字【所有的主属性】组成\r\n\r\n\r\n\r\n#### 分解为BCNF\r\n\r\n![BCNF算法](6-5.png)\r\n\r\n## 第七章、数据库设计\r\n\r\n设计的是*逻辑结构*和*物理结构*\r\n\r\n**基本步骤**\r\n\r\n> 1.系统需求分析阶段\r\n>\r\n> > 使用**自顶向下的结构化分析方法(SA)**，*逐层分析*\r\n> >\r\n> > > SA方法——数据流图\r\n> > >\r\n> > > SA方法——数据字典（数据项、数据结构、数据流、数据存储、处理过程）\r\n>\r\n> 2.概念结构设计阶段【重点】\r\n>\r\n> > 将第一步的抽取为信息结构模型【概念模型】【ER图】（ER图的东西去找第一章的去）\r\n>\r\n> 3.逻辑结构设计阶段【重点】\r\n>\r\n> > 1.一个实体型转换为一个关系模式\r\n> >\r\n> > 2.一个m:n联系转换为一个关系模式\r\n> >\r\n> > 3.1:n联系 \r\n> >\r\n> > > ①转换为一个独立的关系模式\r\n> > >\r\n> > > ②与n端对应的关系模式合并\r\n> >\r\n> > 4.1:1联系\r\n> >\r\n> > > ①转换为一个独立的关系模式\r\n> > >\r\n> > > ②与某一端对应的关系模式合并 \r\n> >\r\n> > 5.三个以上实体间的多元联系转换为一个关系模式\r\n> >\r\n> > 6.同一实体集的实体间的联系，即自联系，也可按上述1:1、1:n和m:n三种情况分别处理\r\n> >\r\n> > 7.具有相同码的关系模式可合并\r\n>\r\n> 4.物理设计阶段\r\n>\r\n> 5.数据库实施阶段\r\n>\r\n> 6.数据库运行与维护阶段\r\n\r\n## 第九章、关系系统和查询优化\r\n\r\n### 关系系统\r\n\r\n**关系系统**就是之前讲的关系数据库的结构、操作、完整性什么的了\r\n\r\n##### 关系系统的分类\r\n\r\n> 表式系统\r\n>\r\n> （最小）关系系统\r\n>\r\n> 关系完备的系统\r\n>\r\n> 全关系系统\r\n\r\n### 关系系统的查询优化\r\n\r\n**查询处理的步骤**：查询分析$\\longrightarrow$查询检查$\\longrightarrow$查询优化$\\longrightarrow$查询执行\r\n\r\n*能根据假设的情景算一下查询调入调出多少磁盘模块*\r\n\r\n**优化的原则**：就那些字面上的意思\r\n\r\n> 查询优化的一般准则\r\n>\r\n> 1.选择运算应尽可能先做（目的：减小中间关系）\r\n>\r\n> 2.在执行连接操作前对关系适当进行预处理：按连接属性排序；在连接属性上建立索引\r\n>\r\n> 3.投影运算和选择运算同时做（目的：避免重复扫描关系）\r\n>\r\n> 4.将投影运算与其前面或后面的双目运算结合\r\n>\r\n> （目的：减少扫描关系的次数）\r\n>\r\n> 5.某些选择运算＋在其前面执行的笛卡尔积 ===>   连接运算\r\n>\r\n> 例如：σS.Sno=SC.Sno(S╳SC) ===> S⋈SC\r\n>\r\n> 6.提取公共子表达式 \r\n\r\n### 代数优化\r\n\r\n优化的**步骤**\r\n\r\n> “李氏”步骤：\r\n>\r\n> 1.写出表连接的骨架和最后选择的属性\r\n>\r\n> 2.从树的上边往下添加选择\r\n>\r\n> 3.从树的上边往下添加投影\r\n>\r\n> 4.检查是不是有的选择、投影是多的\r\n\r\n最后（如果可以的话）笛卡儿积和前边的选择会转化为自然连接\r\n\r\n## 第十章、数据库恢复技术\r\n\r\n### 事务\r\n\r\n````sql\r\nBEGIN TRANSACTION                   \r\n\tSQL 语句1                                             \r\n\tSQL 语句2                                             \r\n\t……                      \r\nCOMMIT 或 ROLLBACK\r\n\r\n````\r\n\r\nCOMMIT:提交【成功】\r\n\r\nROLLBACK:回滚【失败】\r\n\r\n##### 事务特性\r\n\r\n> **原子性**\r\n>\r\n> > 事务不能分割\r\n>\r\n> **一致性**\r\n>\r\n> > 数据库中只有事务成功执行后的结果\r\n>\r\n> **隔离性**\r\n>\r\n> > 对数据的访问是临界的\r\n>\r\n> **持续性**\r\n>\r\n> > 事务成功执行后对数据库的操作是永久的\r\n\r\n### 故障的种类\r\n\r\n> 1.事务故障\r\n>\r\n> 撤销事务，强行回滚\r\n>\r\n> 2.系统故障\r\n>\r\n> 3.介质故障【破坏性很大】\r\n>\r\n> 4.计算机病毒\r\n\r\n### 恢复技术\r\n\r\n**实现原理**：冗余\r\n\r\n**建立冗余方式**：数据转储，日志文件\r\n\r\n##### 数据转储\r\n\r\n![数据转储的分类](10-1.png)\r\n\r\n##### 日志文件\r\n\r\n分类：以**记录**为单位，以**数据块**为单位\r\n\r\n内容：开始标记，结束标记，更新操作\r\n\r\n先更新日志文件，后更新数据库\r\n\r\n### 恢复策略\r\n\r\n事务故障：UNDO\r\n\r\n系统故障：\r\n\r\n![步骤](10-2.png)\r\n\r\n先REDO，再UNDO\r\n\r\n介质故障：\r\n\r\n1.装入最新副本\r\n\r\n> 静态转储直接ok\r\n>\r\n> 动态转储导入数据库副本和项目日志，使用数据库故障恢复方法恢复\r\n\r\n2.装入相关的日志文件副本，REDO\r\n\r\n### 具有检查点的恢复技术\r\n\r\n检查点：统计备份时未提交的事务目录，这样以后用这个备份时就不用检索日志获得UNDO队列了\r\n\r\n![10-3](10-3.png)\r\n\r\n![10-4](10-4.png)\r\n\r\n数据库镜像。。。。\r\n\r\n## 第十一章、并发控制\r\n\r\n【应该不是重点吧】\r\n\r\n#### 并发操作带来的不一致性\r\n\r\n> 丢失修改\r\n>\r\n> > 两个事务并发修改，先改的会被覆盖\r\n>\r\n> 不可重复读\r\n>\r\n> > 读数据后数据被更新\r\n>\r\n> 读脏数据\r\n>\r\n> > 更新了读，读了后更新数据的事务被撤销\r\n\r\n### 锁\r\n\r\n写锁：X\r\n\r\n读锁：S\r\n\r\n​\t![读锁和写锁的相容性](11-1.png)\r\n\r\n### 活锁和死锁\r\n\r\n##### 活锁：不断有人插队$\\longrightarrow$使用先来先服务\r\n\r\n##### 死锁：连个环$\\longrightarrow$\r\n\r\n预防死锁\r\n\r\n> 一次封锁法\r\n>\r\n> 顺序封锁法\r\n\r\n诊断和解除\r\n\r\n> 超时法\r\n>\r\n> **等待图法**【合理】\r\n\r\n### 并发调度的可串行性\r\n\r\n如果并发的结果和某种顺序的串行结果一致，则并发时没有出现错误的\r\n\r\n### 两段锁协议\r\n\r\n一致申$\\longrightarrow$一致放\r\n\r\n分为：扩展阶段和收缩阶段\r\n\r\n### 封锁粒度\r\n\r\n封锁的对象大小\r\n\r\n粒度$\\uparrow      \\longrightarrow     $锁的数量$\\uparrow$，系统开销$\\uparrow$，并发程度$\\uparrow$\r\n\r\nn在多粒度封锁中一个数据对象可能以两种方式封锁：\r\n\r\n显式封锁: 直接加到数据对象上的封锁\r\n\r\n隐式封锁: 由于其上级结点加锁而使该数据对象加上了锁\r\n\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}