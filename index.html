<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Lipengcheng1995.GitHub.com by LiPengcheng1995</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Lipengcheng1995.GitHub.com</h1>
      <h2 class="project-tagline">李鹏程的博客</h2>
    </section>

    <section class="main-content">
      <h1>
<a id="数据库复习" class="anchor" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>数据库复习</h1>

<h2>
<a id="第一章绪论" class="anchor" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%BB%AA%E8%AE%BA" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>第一章、绪论</h2>

<h3>
<a id="概念比较多" class="anchor" href="#%E6%A6%82%E5%BF%B5%E6%AF%94%E8%BE%83%E5%A4%9A" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>概念比较多</h3>

<h3>
<a id="11数据库系统概述" class="anchor" href="#11%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1.1数据库系统概述</h3>

<h4>
<a id="数据库基本概念" class="anchor" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>数据库基本概念</h4>

<blockquote>
<h4>
<a id="1数据" class="anchor" href="#1%E6%95%B0%E6%8D%AE" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1.数据：</h4>

<blockquote>
<p>数据库中的基本对象，是描述事物的符号</p>
</blockquote>

<h4>
<a id="2数据库" class="anchor" href="#2%E6%95%B0%E6%8D%AE%E5%BA%93" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.数据库</h4>

<blockquote>
<p><strong>长期存贮</strong>在计算机中，<strong>有组织的</strong>，<strong>可共享的</strong>大量数据的集合</p>
</blockquote>

<h4>
<a id="3数据库管理系统dbms" class="anchor" href="#3%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9Fdbms" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.数据库管理系统（DBMS）</h4>

<blockquote>
<p>用户与操作系统之间的一层软件，用于<strong>科学组织存储数据，高效获取和维护数据</strong></p>

<blockquote>
<p><em>sql server</em>属于数据库管理系统</p>
</blockquote>
</blockquote>

<h4>
<a id="4数据库系统dbs" class="anchor" href="#4%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9Fdbs" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.数据库系统（DBS）</h4>

<blockquote>
<p>计算机系统引入数据库后的系统</p>

<h5>
<a id="构成" class="anchor" href="#%E6%9E%84%E6%88%90" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>构成：</h5>

<blockquote>
<p>DB</p>

<p>DBMS</p>

<p>Application System</p>

<p>DataBase Administrator(DBA)</p>
</blockquote>
</blockquote>
</blockquote>

<h4>
<a id="数据管理技术的产生与发展" class="anchor" href="#%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E7%9A%84%E4%BA%A7%E7%94%9F%E4%B8%8E%E5%8F%91%E5%B1%95" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>数据管理技术的产生与发展</h4>

<blockquote>
<p>1.人工管理阶段</p>

<p>2.文件系统阶段</p>

<p>3.数据库系统阶段</p>
</blockquote>

<h4>
<a id="数据库系统的特点" class="anchor" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E7%82%B9" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>数据库系统的特点</h4>

<blockquote>
<p>1.整体数据结构化</p>

<p>2.数据的共享性高、冗余度低、易于扩充</p>

<p>3.数据独立性高</p>

<p>4.数据由DBMS同一管理和控制</p>
</blockquote>

<h3>
<a id="12数据模型" class="anchor" href="#12%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1.2数据模型</h3>

<h4>
<a id="分类" class="anchor" href="#%E5%88%86%E7%B1%BB" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>分类</h4>

<p><strong>概念模型</strong></p>

<p><strong>逻辑模型和物理模型</strong></p>

<h4>
<a id="组成要素" class="anchor" href="#%E7%BB%84%E6%88%90%E8%A6%81%E7%B4%A0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>组成要素</h4>

<p><em>用来描述，组织，操作数据</em></p>

<blockquote>
<p>1.数据结构【数据库组成对象及之间联系】</p>

<p>2.数据操作【查询、更新等】</p>

<p>3.完整性约束【制约依存规则】【保证数据的<strong>正确性、有效性、相容性</strong>】</p>
</blockquote>

<h4>
<a id="概念模型和er方法" class="anchor" href="#%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B%E5%92%8Cer%E6%96%B9%E6%B3%95" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>概念模型和ER方法</h4>

<p><em>概念模型</em>又叫信息模型，强调语义表达能力，主要用于<strong>数据库设计</strong>,是 <strong>现实世界的第一层抽象</strong></p>

<p><em>逻辑模型和物理模型</em>按照计算机观点进行数据建模</p>

<p><img src="1-1.png" alt="概念模型和逻辑、物理模型"></p>

<blockquote>
<p>概念模型：</p>

<p>*实体</p>

<p>*属性</p>

<p><em>码：</em><em>唯一标识</em>*实体的属性集</p>

<p>*域</p>

<p>*实体型：用实体名和属性名集合来抽象和刻画同类实体</p>

<p>*实体集：同一类实际集合</p>

<p>*联系：分为一对一，一对多，多对多</p>
</blockquote>

<h5>
<a id="er模型" class="anchor" href="#er%E6%A8%A1%E5%9E%8B" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ER模型</h5>

<p><img src="1-2.png" alt="ER构成"></p>

<p><strong>注意：</strong></p>

<blockquote>
<p>1.实体名、联系名不可以重复出现【不能由重名】</p>

<p>2.一个实体也不能多次出现【一个实体型就是一个矩形，不能画多了】</p>
</blockquote>

<h4>
<a id="最常用的数据模型" class="anchor" href="#%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>最常用的数据模型</h4>

<blockquote>
<p>1.层次模型【非关系模型】</p>

<blockquote>
<p>树图展示</p>

<p>优点：简单高效</p>

<p>缺点：不通用，插入删除复杂，访问复杂</p>
</blockquote>

<p>2.网状模型【非关系模型】</p>

<p>3.<strong>关系模型</strong></p>

<p>4.面向对象模型</p>

<p>5.对象关系模型  </p>
</blockquote>

<h2>
<a id="第二章关系数据库" class="anchor" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>第二章、关系数据库</h2>

<h3>
<a id="1关系数据结构" class="anchor" href="#1%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1.关系数据结构</h3>

<blockquote>
<p>候选码</p>

<p>主码</p>

<p>主属性：主码和候选码中的属性</p>

<p>非码属性</p>

<p>全码：关系中所有的属性都是<em>候选码</em>，称为主码</p>

<blockquote>
<p>个人意见：斜体部分是“候选码”而不是“主属性”，这个是由条件的，自己想</p>
</blockquote>

<p>外部码：外码。不是本关系的码，而是其他关系【可以是本关系，自己与自己链接，班长的那个例子】的码</p>

<p>​   外码不一定与对应的主码同名</p>

<p>关系模式：
$$</p>

<p>$$</p>

<p>$$
R(U,D,DOM,F)
$$</p>

<p>R:关系名</p>

<p>U:属性名集合</p>

<p>D：域集合</p>

<p>DOM：U到D的映射</p>

<p>F：U中属性之间的依赖集合</p>

<p>● 关系模式是型，是静态的、稳定的；</p>

<p>● 关系是关系模式的值，是动态的、随时间而变化的。 </p>

<p>关系型数据库：</p>

<p><img src="2-1.png" alt="完整性约束"></p>

<p>实体完整性：主属性不能为空</p>

<p>参照完整性：外码的取值</p>

<blockquote>
<p>要么为空</p>

<p>要么等于对应的属性的主码</p>
</blockquote>
</blockquote>

<h3>
<a id="2关系操作" class="anchor" href="#2%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.关系操作</h3>

<h4>
<a id="集合运算bigcup-bigcap--" class="anchor" href="#%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97bigcup-bigcap--" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>集合运算$\bigcup \bigcap -$</h4>

<p>就是集合运算那些东西</p>

<h4>
<a id="专门的关系运算sigma--pi--times-div" class="anchor" href="#%E4%B8%93%E9%97%A8%E7%9A%84%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97sigma--pi--times-div" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>专门的关系运算$\sigma , \pi , \times ,\div$</h4>

<p>$$
\sigma \Sigma \varsigma \tau T \upsilon \Upsilon</p>

<p>\phi \Phi \varphi \chi X \psi \Psi \omega \Omega
$$
<em>tips</em>： 在$\sigma$【选择】和$\pi$【投影】时，对应的列可以用数字代替，从左往右从1开始</p>

<p>笛卡儿积产生的结果中有大量的<strong>平庸元组</strong>需要剔除</p>

<h4>
<a id="连接" class="anchor" href="#%E8%BF%9E%E6%8E%A5" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>连接</h4>

<blockquote>
<p>笛卡儿积 + 选择 = 条件连接</p>

<p>分类：</p>

<p>1.等值连接</p>

<p>​   $\sigma$的条件是等号</p>

<p>2.自然连接</p>

<p>​   连接时的条件必须是相同的，连接后去除重复属性列</p>

<p>3.外连接</p>

<p>​   左外连接</p>

<p>​       保留左侧要舍弃的元组</p>

<p>​   右外联结</p>

<p>​       保留右侧要舍弃的元组  </p>
</blockquote>

<h4>
<a id="div" class="anchor" href="#div" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>$\div$</h4>

<blockquote>
<p>象集：$Z_x1$在关系中取$x=x_1$的元组，并去除$x$列</p>

<p>除法：n给定关系R (X, Y) 和S(Y, Z)，X、Y、Z为属性组。¨元组在X上分量值x的象集Yx包含S在Y上投影的集合。</p>
</blockquote>

<h3>
<a id="3关系完整性约束" class="anchor" href="#3%E5%85%B3%E7%B3%BB%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.关系完整性约束</h3>

<h3>
<a id="4关系代数运算" class="anchor" href="#4%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E8%BF%90%E7%AE%97" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.关系代数运算</h3>

<h2>
<a id="第三章-关系数据库标准语言sql" class="anchor" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86%E8%AF%AD%E8%A8%80sql" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>第三章、 关系数据库标准语言SQL</h2>

<h3>
<a id="1sql特点" class="anchor" href="#1sql%E7%89%B9%E7%82%B9" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1.SQL特点</h3>

<p>！@#%！@%#￥@……@#￥%&amp;……%#￥&amp;%￥@￥！#￥！%！#￥……！#￥@#！%</p>

<h3>
<a id="2sql使用数据定义" class="anchor" href="#2sql%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.SQL使用——数据定义</h3>

<h4>
<a id="模式" class="anchor" href="#%E6%A8%A1%E5%BC%8F" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>模式</h4>

<div class="highlight highlight-source-sql"><pre>CREATE SCHEMA <span class="pl-s"><span class="pl-pds">"</span>模式名<span class="pl-pds">"</span></span> AUTHORIZATION “用户名”

<span class="pl-k">DROP</span> <span class="pl-k">SCHEMA</span> <span class="pl-s"><span class="pl-pds">"</span>模式名<span class="pl-pds">"</span></span> [CASCADE | RESTRICT]
</pre></div>

<h4>
<a id="基本表" class="anchor" href="#%E5%9F%BA%E6%9C%AC%E8%A1%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>基本表</h4>

<p><strong>表的建立</strong></p>

<div class="highlight highlight-source-sql"><pre><span class="pl-k">CREATE</span> <span class="pl-k">TABLE</span> <span class="pl-en">SC</span>
  (     Sno  <span class="pl-k">CHAR</span>(<span class="pl-c1">9</span>), 
        Cno  <span class="pl-k">CHAR</span>(<span class="pl-c1">4</span>),  
        Grade    <span class="pl-k">SMALLINT</span>,
        <span class="pl-k">PRIMARY KEY</span> (Sno, Cno), <span class="pl-c">/* 主码由两个属性构成， 必须作为表级完整性进行定义*/</span>
        <span class="pl-k">FOREIGN KEY</span> (Sno) <span class="pl-k">REFERENCES</span> Student(Sno),
         <span class="pl-c">/* 表级完整性约束条件，Sno是外码，被参照表是Student */</span>
        <span class="pl-k">FOREIGN KEY</span> (Cno) <span class="pl-k">REFERENCES</span> Course(Cno)
         <span class="pl-c">/* 表级完整性约束条件， Cno是外码，被参照表是Course*/</span>
  );
</pre></div>

<p><img src="3-1.png" alt="了解"></p>

<p><strong>表的修改</strong></p>

<div class="highlight highlight-source-sql"><pre><span class="pl-k">ALTER</span> <span class="pl-k">TABLE</span> <span class="pl-k">&lt;</span>表名<span class="pl-k">&gt;</span>        
              [RENAME <span class="pl-k">&lt;</span>旧表名<span class="pl-k">&gt;</span> TO <span class="pl-k">&lt;</span>新表名<span class="pl-k">&gt;</span>];
            [ADD <span class="pl-k">&lt;</span>新列名<span class="pl-k">&gt;</span> <span class="pl-k">&lt;</span>数据类型<span class="pl-k">&gt;</span>[完整性约束]]
            [DROP <span class="pl-k">&lt;</span>列名<span class="pl-k">&gt;</span> ]
            [ALTER COLUMN <span class="pl-k">&lt;</span>列名<span class="pl-k">&gt;</span> <span class="pl-k">&lt;</span>数据类型<span class="pl-k">&gt;</span>]
            [ADD <span class="pl-k">&lt;</span>完整性约束<span class="pl-k">&gt;</span>]
            [DROP <span class="pl-k">&lt;</span>完整性约束名<span class="pl-k">&gt;</span>]
</pre></div>

<p><strong>表的删除</strong></p>

<div class="highlight highlight-source-sql"><pre><span class="pl-k">DROP</span>  <span class="pl-k">TABLE</span>  <span class="pl-k">&lt;</span>表名<span class="pl-k">&gt;</span> ［RESTRICT| CASCADE］;
</pre></div>

<h4>
<a id="索引" class="anchor" href="#%E7%B4%A2%E5%BC%95" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>索引</h4>

<p><strong>索引分类</strong></p>

<blockquote>
<p>唯一索引：</p>

<blockquote>
<p>要求对应的列没有重复值</p>
</blockquote>

<p>聚簇索引：</p>

<blockquote>
<p>改变对应的物理顺序</p>

<p>一个表只能有一个聚簇索引</p>
</blockquote>
</blockquote>

<p><strong>索引建立与删除</strong></p>

<div class="highlight highlight-source-sql"><pre>CREATE  [UNIQUE] [CLUSTER]  INDEX <span class="pl-k">&lt;</span>索引名<span class="pl-k">&gt;</span>
        <span class="pl-k">ON</span> <span class="pl-k">&lt;</span>表名<span class="pl-k">&gt;</span> (<span class="pl-k">&lt;</span>列名<span class="pl-k">&gt;</span>[<span class="pl-k">&lt;</span>次序<span class="pl-k">ASC</span>|<span class="pl-k">DESC</span><span class="pl-k">&gt;</span>],[, <span class="pl-k">&lt;</span>列名<span class="pl-k">&gt;</span>[<span class="pl-k">&lt;</span>次序<span class="pl-k">&gt;</span>]]…)；
<span class="pl-k">DROP</span> <span class="pl-k">INDEX</span> <span class="pl-k">&lt;</span>表名.索引名<span class="pl-k">&gt;</span>；</pre></div>

<h4>
<a id="视图" class="anchor" href="#%E8%A7%86%E5%9B%BE" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>视图</h4>

<p>见视图专题</p>

<h3>
<a id="3sql使用数据查询" class="anchor" href="#3sql%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.SQL使用——数据查询</h3>

<p><strong>格式</strong></p>

<div class="highlight highlight-source-sql"><pre> <span class="pl-k">SELECT</span> [ALL|DISTINCT] <span class="pl-k">&lt;</span>目标列表达式<span class="pl-k">&gt;</span>
                       [, <span class="pl-k">&lt;</span>目标列表达式<span class="pl-k">&gt;</span>]……
    <span class="pl-k">FROM</span>  <span class="pl-k">&lt;</span>表名或视图名<span class="pl-k">&gt;</span>[,<span class="pl-k">&lt;</span>表名或视图名<span class="pl-k">&gt;</span>] …
   [<span class="pl-k">WHERE</span>  <span class="pl-k">&lt;</span>条件表达式<span class="pl-k">&gt;</span>]
   [GROUP  BY <span class="pl-k">&lt;</span>列名<span class="pl-c1">1</span><span class="pl-k">&gt;</span> [<span class="pl-k">HAVING</span>  <span class="pl-k">&lt;</span>条件表达式<span class="pl-k">&gt;</span>]]
   [<span class="pl-k">ORDER BY</span> <span class="pl-k">&lt;</span>列名<span class="pl-c1">2</span><span class="pl-k">&gt;</span>[<span class="pl-k">ASC</span>|<span class="pl-k">DESC</span>]]；
</pre></div>

<p><strong>查询分类</strong></p>

<blockquote>
<p>单表查询</p>

<p>多表查询</p>

<blockquote>
<p>注意：外连接<code>left out join on(关系)</code>,<code>right out join on (关系)</code>,<code>out join(关系)</code></p>
</blockquote>

<p>嵌套查询</p>

<blockquote>
<p>分类：</p>

<p>相关子查询</p>

<p>不相关子查询</p>

<p>聚集函数</p>

<p>ANY,ALL</p>

<p>IN、EXISTS  <strong>使用NOT EXISTS取反实现全称量词】</strong></p>
</blockquote>

<p>集合查询【UNION INTERSECT EXCEPT】</p>

<blockquote>
<p>注意：</p>

<blockquote>
<p>1.要排序的话只能在最后排一次</p>

<p>2.操作的两部分对应的列要完全一致</p>
</blockquote>
</blockquote>
</blockquote>

<h3>
<a id="4sql使用数据更新" class="anchor" href="#4sql%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.SQL使用——数据更新</h3>

<h4>
<a id="插入" class="anchor" href="#%E6%8F%92%E5%85%A5" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>插入</h4>

<div class="highlight highlight-source-sql"><pre><span class="pl-k">INSERT INTO</span> <span class="pl-k">&lt;</span>表名<span class="pl-k">&gt;</span>[(<span class="pl-k">&lt;</span>列名<span class="pl-c1">1</span><span class="pl-k">&gt;</span>[,<span class="pl-k">&lt;</span>列名<span class="pl-c1">2</span><span class="pl-k">&gt;</span>]…)]
     <span class="pl-k">VALUES</span>( <span class="pl-k">&lt;</span>常量<span class="pl-c1">1</span><span class="pl-k">&gt;</span>[,<span class="pl-k">&lt;</span>常量<span class="pl-c1">2</span><span class="pl-k">&gt;</span>]…)；


<span class="pl-k">INSERT  INTO</span>   Dept_age( Sdept, Avgage )  
        <span class="pl-k">SELECT</span> Sdept, <span class="pl-c1">AVG</span>(Sage)
        <span class="pl-k">FROM</span>   Student
        <span class="pl-k">GROUP BY</span> Sdept;
</pre></div>

<h4>
<a id="修改" class="anchor" href="#%E4%BF%AE%E6%94%B9" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>修改</h4>

<div class="highlight highlight-source-sql"><pre>   <span class="pl-k">UPDATE</span> <span class="pl-k">&lt;</span>表名<span class="pl-k">&gt;</span> 
   <span class="pl-k">SET</span>  <span class="pl-k">&lt;</span>列名<span class="pl-k">&gt;=&lt;</span>表达式<span class="pl-k">&gt;</span> [,<span class="pl-k">&lt;</span>列名<span class="pl-k">&gt;=&lt;</span>表达式<span class="pl-k">&gt;</span>]…

</pre></div>

<h4>
<a id="删除" class="anchor" href="#%E5%88%A0%E9%99%A4" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>删除</h4>

<div class="highlight highlight-source-sql"><pre> <span class="pl-k">DELETE</span>  
 <span class="pl-k">FROM</span>    <span class="pl-k">&lt;</span>表名<span class="pl-k">&gt;</span>
 [<span class="pl-k">WHERE</span>  <span class="pl-k">&lt;</span>条件<span class="pl-k">&gt;</span>]；
</pre></div>

<h3>
<a id="5sql使用视图专题" class="anchor" href="#5sql%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE%E4%B8%93%E9%A2%98" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>5.SQL使用——视图专题</h3>

<h4>
<a id="视图创建" class="anchor" href="#%E8%A7%86%E5%9B%BE%E5%88%9B%E5%BB%BA" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>视图创建</h4>

<div class="highlight highlight-source-sql"><pre>CREATE VIEW <span class="pl-k">&lt;</span>视图名<span class="pl-k">&gt;</span>[(<span class="pl-k">&lt;</span>列名<span class="pl-k">&gt;</span>[,<span class="pl-k">&lt;</span>列名<span class="pl-k">&gt;</span>]…)]
      <span class="pl-k">AS</span> 子查询
      [WITH <span class="pl-k">CHECK</span> OPTION]；
</pre></div>

<h4>
<a id="视图删除" class="anchor" href="#%E8%A7%86%E5%9B%BE%E5%88%A0%E9%99%A4" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>视图删除</h4>

<div class="highlight highlight-source-sql"><pre><span class="pl-k">DROP</span>  <span class="pl-k">VIEW</span>  <span class="pl-k">&lt;</span>视图名<span class="pl-k">&gt;</span> [ CASCADE ] ； </pre></div>

<h4>
<a id="视图消解重要" class="anchor" href="#%E8%A7%86%E5%9B%BE%E6%B6%88%E8%A7%A3%E9%87%8D%E8%A6%81" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>视图消解【重要】</h4>

<p>出错原因：消解是机械式的，可能会把聚集函数整到WHERE里面，造成错误</p>

<h4>
<a id="视图更新" class="anchor" href="#%E8%A7%86%E5%9B%BE%E6%9B%B4%E6%96%B0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>视图更新</h4>

<p>不可更新的视图：【了解】</p>

<blockquote>
<p>•由多个表导出的视图，不可更新</p>

<p>•视图的列来自表达式或常数，不可插入、修改、可删除</p>

<p>•视图列是来自集函数，不可更新</p>

<p>•视图定义中含有GROUP BY子句，不可更新</p>

<p>•视图定义中含有DISTINCT短语，不可更新</p>

<p>•视图定义中内层嵌套的表与导出该视图表相同，不可更新</p>

<p>•在不允许更新的视图上定义的视图，不可更新</p>
</blockquote>

<h2>
<a id="第四章数据库安全性" class="anchor" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>第四章、数据库安全性</h2>

<h3>
<a id="用户识别" class="anchor" href="#%E7%94%A8%E6%88%B7%E8%AF%86%E5%88%AB" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>用户识别</h3>

<blockquote>
<p>用户标识</p>

<p>口令</p>
</blockquote>

<h3>
<a id="存取控制" class="anchor" href="#%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>存取控制</h3>

<p>数据库安全<strong>最重要</strong>的一点就是确保只授权给有资格的用户访问数据库的权限</p>

<h4>
<a id="方法分类" class="anchor" href="#%E6%96%B9%E6%B3%95%E5%88%86%E7%B1%BB" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>方法分类</h4>

<blockquote>
<p>自主存取控制（DAC）</p>

<div class="highlight highlight-source-sql"><pre><span class="pl-k">GRANT</span> <span class="pl-k">&lt;</span>权限<span class="pl-k">&gt;</span> [, <span class="pl-k">&lt;</span>权限<span class="pl-k">&gt;</span> ]……
      [ <span class="pl-k">ON</span> <span class="pl-k">&lt;</span>对象类型<span class="pl-k">&gt;&lt;</span>对象名<span class="pl-k">&gt;</span>]    
      TO <span class="pl-k">&lt;</span>用户<span class="pl-k">&gt;</span>[, <span class="pl-k">&lt;</span>用户<span class="pl-k">&gt;</span>]……
      [ WITH <span class="pl-k">GRANT</span> OPTION ]；



<span class="pl-k">REVOKE</span> <span class="pl-k">&lt;</span>权限<span class="pl-k">&gt;</span> [, <span class="pl-k">&lt;</span>权限<span class="pl-k">&gt;</span> ]……
      [ <span class="pl-k">ON</span> <span class="pl-k">&lt;</span>对象类型<span class="pl-k">&gt;&lt;</span>对象名<span class="pl-k">&gt;</span>]    
      <span class="pl-k">FROM</span> <span class="pl-k">&lt;</span>用户<span class="pl-k">&gt;</span>[, <span class="pl-k">&lt;</span>用户<span class="pl-k">&gt;</span>]……</pre></div>

<p><img src="4-1.png" alt="权限"></p>

<p>强制存取控制(MAC)</p>

<blockquote>
<p>敏感度标记（Label）。敏感度标记被分为若干级别，例如：</p>

<p>绝密（TopSecret）</p>

<p>机密（Secret）</p>

<p>可信（Confidential）</p>

<p>公开（Public） 等</p>

<p>¨主体的敏感度标记称为许可证级别（ClearanceLevel）；</p>

<p>¨客体的敏感度标记称为密级（Classification Level）。</p>
</blockquote>
</blockquote>

<p>DAC与MAC共同构成DBMS的安全机制</p>

<p>¨实现MAC时要首先实现DAC，原因是：较高安全性级别提供的安全保护要包含较低级别的所有保护。</p>

<h2>
<a id="第五章数据库完整性" class="anchor" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>第五章、数据库完整性</h2>

<h4>
<a id="分类-1" class="anchor" href="#%E5%88%86%E7%B1%BB-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>分类：</h4>

<blockquote>
<p>实体完整性</p>

<blockquote>
<p>primary key</p>
</blockquote>

<p>参照完整性</p>

<blockquote>
<p><img src="5-1.png" alt="用户自定义完整性">用户自定义完整性,限制的主要是<strong>参照表</strong></p>
</blockquote>

<p>用户自定义完整性</p>

<blockquote>
<p>UNIQUE 、NOT NULL 、CHECK</p>

<blockquote>
<p>CHECK的写法：就像sql查询中where条件里那么写就行了</p>
</blockquote>
</blockquote>
</blockquote>

<h4>
<a id="触发器" class="anchor" href="#%E8%A7%A6%E5%8F%91%E5%99%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>触发器</h4>

<div class="highlight highlight-source-sql"><pre>CREATE  TRIGGER  <span class="pl-k">&lt;</span>触发器名<span class="pl-k">&gt;</span>
             { BEFORE | AFTER }  <span class="pl-k">&lt;</span>触发事件<span class="pl-k">&gt;</span> <span class="pl-k">ON</span> <span class="pl-k">&lt;</span>表名<span class="pl-k">&gt;</span>
              FOR  EACH  {  ROW | STATEMENT  }
              [ WHEN <span class="pl-k">&lt;</span>触发事件<span class="pl-k">&gt;</span>]
              <span class="pl-k">&lt;</span>触发动作体<span class="pl-k">&gt;</span>
<span class="pl-k">//</span>SQL SERVER 以这个为主吧
CREATE  TRIGGER   触发器名
       <span class="pl-k">ON</span>  数据表名或视图名
       AFTER | FOR| Instead of   INSERT 或 <span class="pl-k">DELETE</span> 或 <span class="pl-k">UPDATE</span> 
<span class="pl-k">AS</span> 
<span class="pl-k">BEGIN</span>  
         <span class="pl-c">--这里是要运行的SQL语句</span>
END 
GO</pre></div>

<p>deleted表和inserted表</p>

<p><img src="5-2.png" alt="hehe"></p>

<h2>
<a id="第六章关系数据理论" class="anchor" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>第六章、关系数据理论</h2>

<p><em>引入</em>：关系模式在前边就已经提到过了，这里更多的讨论的是属性见关系，所以将关系模式表示为关系模式名R，属性名U,属性间关系F的三元组$R(U,F)$</p>

<h3>
<a id="数据依赖的分类" class="anchor" href="#%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E7%9A%84%E5%88%86%E7%B1%BB" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>数据依赖的分类</h3>

<p>1.函数依赖【我们后边讨论的都是这个】</p>

<p>2.多值依赖</p>

<h3>
<a id="函数依赖的分类" class="anchor" href="#%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E7%9A%84%E5%88%86%E7%B1%BB" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>函数依赖的分类</h3>

<blockquote>
<p>平凡函数依赖：（类似$AB \rightarrow A$）</p>

<p>非平凡函数依赖：(类似$AB\rightarrow C$)</p>

<p>完全函数依赖：（类似：$AB \rightarrow C$，但是$A \nrightarrow C$而且$B \nrightarrow C$）</p>

<p>部分函数依赖：(类似：$AB \rightarrow C$,但是存在一个现象$A \rightarrow C$)</p>

<p>直接函数依赖：</p>

<p>传递函数依赖：($A\rightarrow B , B\rightarrow C  \Longrightarrow A\rightarrow C$)</p>
</blockquote>

<h3>
<a id="范式" class="anchor" href="#%E8%8C%83%E5%BC%8F" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>范式</h3>

<p>范式分类：</p>

<p><img src="6-1.png" alt="范式分类及范式之间的关系"></p>

<h3>
<a id="armstrong公理系统" class="anchor" href="#armstrong%E5%85%AC%E7%90%86%E7%B3%BB%E7%BB%9F" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Armstrong公理系统</h3>

<p><em>定位</em>：一套用于<strong>模式分解算法</strong>的<strong>推理规则</strong></p>

<p>自反律</p>

<p>增广律</p>

<p>传递律</p>

<p>合并规则：</p>

<p>分解规则：</p>

<p>伪传递规则：$X\rightarrow Y , YZ\rightarrow A   \Longrightarrow XZ\rightarrow A$</p>

<h3>
<a id="闭包" class="anchor" href="#%E9%97%AD%E5%8C%85" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>闭包</h3>

<p><img src="6-2.png" alt="闭包的求解步骤"></p>

<h3>
<a id="最小依赖集" class="anchor" href="#%E6%9C%80%E5%B0%8F%E4%BE%9D%E8%B5%96%E9%9B%86" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>最小依赖集</h3>

<p><img src="6-3.png" alt="最小依赖集的概念，要满足的条件"></p>

<p>求最小依赖集的步骤：</p>

<blockquote>
<p>1.对右部的属性进行分解，保持右部只有一个属性</p>

<p>2.依次检查每一个公式是够必须的公式</p>

<blockquote>
<p>去掉此公式，然后求左侧属性的闭包，看能不能包括右侧属性</p>
</blockquote>

<p>3.依次检查每个公式左侧的每一个属性是否此公式必须的属性</p>

<blockquote>
<p>一个一个的尝试去掉左侧的属性，【但是保留本公式】，看剩下的属性的闭包能否包含右侧的属性</p>
</blockquote>
</blockquote>

<h3>
<a id="求解关系模式的候选码" class="anchor" href="#%E6%B1%82%E8%A7%A3%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%80%99%E9%80%89%E7%A0%81" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>求解关系模式的候选码</h3>

<p>属性分类：</p>

<p><img src="6-4.png" alt="L,R,LR,N属性的定义及使用方法"></p>

<h3>
<a id="模式分解" class="anchor" href="#%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>模式分解</h3>

<p>要求：保证分解后的关系模式与原关系模式等价【。。。。】</p>

<p>等价包括：</p>

<blockquote>
<p>分解具有“无损连接性” （Losslessjoin）</p>

<p>分解要“保持函数依赖” （Preservedependency）</p>

<p>分解既要“保持函数依赖”，又要具有“无损连接性”</p>
</blockquote>

<p><strong>分解为第三范式</strong>：</p>

<p>保留函数依赖：</p>

<blockquote>
<p>F最小化 </p>

<p>一个推导式弄做一个模式</p>
</blockquote>

<p>保留函数依赖和无损联结：在上边的基础上加一个关系模式，里边由候选码关键字【所有的主属性】组成</p>

<h4>
<a id="分解为bcnf" class="anchor" href="#%E5%88%86%E8%A7%A3%E4%B8%BAbcnf" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>分解为BCNF</h4>

<p><img src="6-5.png" alt="BCNF算法"></p>

<h2>
<a id="第七章数据库设计" class="anchor" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>第七章、数据库设计</h2>

<p>设计的是<em>逻辑结构</em>和<em>物理结构</em></p>

<p><strong>基本步骤</strong></p>

<blockquote>
<p>1.系统需求分析阶段</p>

<blockquote>
<p>使用<strong>自顶向下的结构化分析方法(SA)</strong>，<em>逐层分析</em></p>

<blockquote>
<p>SA方法——数据流图</p>

<p>SA方法——数据字典（数据项、数据结构、数据流、数据存储、处理过程）</p>
</blockquote>
</blockquote>

<p>2.概念结构设计阶段【重点】</p>

<blockquote>
<p>将第一步的抽取为信息结构模型【概念模型】【ER图】（ER图的东西去找第一章的去）</p>
</blockquote>

<p>3.逻辑结构设计阶段【重点】</p>

<blockquote>
<p>1.一个实体型转换为一个关系模式</p>

<p>2.一个m:n联系转换为一个关系模式</p>

<p>3.1:n联系 </p>

<blockquote>
<p>①转换为一个独立的关系模式</p>

<p>②与n端对应的关系模式合并</p>
</blockquote>

<p>4.1:1联系</p>

<blockquote>
<p>①转换为一个独立的关系模式</p>

<p>②与某一端对应的关系模式合并 </p>
</blockquote>

<p>5.三个以上实体间的多元联系转换为一个关系模式</p>

<p>6.同一实体集的实体间的联系，即自联系，也可按上述1:1、1:n和m:n三种情况分别处理</p>

<p>7.具有相同码的关系模式可合并</p>
</blockquote>

<p>4.物理设计阶段</p>

<p>5.数据库实施阶段</p>

<p>6.数据库运行与维护阶段</p>
</blockquote>

<h2>
<a id="第九章关系系统和查询优化" class="anchor" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0%E5%85%B3%E7%B3%BB%E7%B3%BB%E7%BB%9F%E5%92%8C%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>第九章、关系系统和查询优化</h2>

<h3>
<a id="关系系统" class="anchor" href="#%E5%85%B3%E7%B3%BB%E7%B3%BB%E7%BB%9F" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>关系系统</h3>

<p><strong>关系系统</strong>就是之前讲的关系数据库的结构、操作、完整性什么的了</p>

<h5>
<a id="关系系统的分类" class="anchor" href="#%E5%85%B3%E7%B3%BB%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E7%B1%BB" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>关系系统的分类</h5>

<blockquote>
<p>表式系统</p>

<p>（最小）关系系统</p>

<p>关系完备的系统</p>

<p>全关系系统</p>
</blockquote>

<h3>
<a id="关系系统的查询优化" class="anchor" href="#%E5%85%B3%E7%B3%BB%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>关系系统的查询优化</h3>

<p><strong>查询处理的步骤</strong>：查询分析$\longrightarrow$查询检查$\longrightarrow$查询优化$\longrightarrow$查询执行</p>

<p><em>能根据假设的情景算一下查询调入调出多少磁盘模块</em></p>

<p><strong>优化的原则</strong>：就那些字面上的意思</p>

<blockquote>
<p>查询优化的一般准则</p>

<p>1.选择运算应尽可能先做（目的：减小中间关系）</p>

<p>2.在执行连接操作前对关系适当进行预处理：按连接属性排序；在连接属性上建立索引</p>

<p>3.投影运算和选择运算同时做（目的：避免重复扫描关系）</p>

<p>4.将投影运算与其前面或后面的双目运算结合</p>

<p>（目的：减少扫描关系的次数）</p>

<p>5.某些选择运算＋在其前面执行的笛卡尔积 ===&gt;   连接运算</p>

<p>例如：σS.Sno=SC.Sno(S╳SC) ===&gt; S⋈SC</p>

<p>6.提取公共子表达式 </p>
</blockquote>

<h3>
<a id="代数优化" class="anchor" href="#%E4%BB%A3%E6%95%B0%E4%BC%98%E5%8C%96" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>代数优化</h3>

<p>优化的<strong>步骤</strong></p>

<blockquote>
<p>“李氏”步骤：</p>

<p>1.写出表连接的骨架和最后选择的属性</p>

<p>2.从树的上边往下添加选择</p>

<p>3.从树的上边往下添加投影</p>

<p>4.检查是不是有的选择、投影是多的</p>
</blockquote>

<p>最后（如果可以的话）笛卡儿积和前边的选择会转化为自然连接</p>

<h2>
<a id="第十章数据库恢复技术" class="anchor" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>第十章、数据库恢复技术</h2>

<h3>
<a id="事务" class="anchor" href="#%E4%BA%8B%E5%8A%A1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>事务</h3>

<div class="highlight highlight-source-sql"><pre><span class="pl-k">BEGIN</span> TRANSACTION                   
    SQL 语句<span class="pl-c1">1</span>                                             
    SQL 语句<span class="pl-c1">2</span>                                             
    ……                      
<span class="pl-k">COMMIT</span> 或 <span class="pl-k">ROLLBACK</span>
</pre></div>

<p>COMMIT:提交【成功】</p>

<p>ROLLBACK:回滚【失败】</p>

<h5>
<a id="事务特性" class="anchor" href="#%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>事务特性</h5>

<blockquote>
<p><strong>原子性</strong></p>

<blockquote>
<p>事务不能分割</p>
</blockquote>

<p><strong>一致性</strong></p>

<blockquote>
<p>数据库中只有事务成功执行后的结果</p>
</blockquote>

<p><strong>隔离性</strong></p>

<blockquote>
<p>对数据的访问是临界的</p>
</blockquote>

<p><strong>持续性</strong></p>

<blockquote>
<p>事务成功执行后对数据库的操作是永久的</p>
</blockquote>
</blockquote>

<h3>
<a id="故障的种类" class="anchor" href="#%E6%95%85%E9%9A%9C%E7%9A%84%E7%A7%8D%E7%B1%BB" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>故障的种类</h3>

<blockquote>
<p>1.事务故障</p>

<p>撤销事务，强行回滚</p>

<p>2.系统故障</p>

<p>3.介质故障【破坏性很大】</p>

<p>4.计算机病毒</p>
</blockquote>

<h3>
<a id="恢复技术" class="anchor" href="#%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>恢复技术</h3>

<p><strong>实现原理</strong>：冗余</p>

<p><strong>建立冗余方式</strong>：数据转储，日志文件</p>

<h5>
<a id="数据转储" class="anchor" href="#%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%82%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>数据转储</h5>

<p><img src="10-1.png" alt="数据转储的分类"></p>

<h5>
<a id="日志文件" class="anchor" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>日志文件</h5>

<p>分类：以<strong>记录</strong>为单位，以<strong>数据块</strong>为单位</p>

<p>内容：开始标记，结束标记，更新操作</p>

<p>先更新日志文件，后更新数据库</p>

<h3>
<a id="恢复策略" class="anchor" href="#%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>恢复策略</h3>

<p>事务故障：UNDO</p>

<p>系统故障：</p>

<p><img src="10-2.png" alt="步骤"></p>

<p>先REDO，再UNDO</p>

<p>介质故障：</p>

<p>1.装入最新副本</p>

<blockquote>
<p>静态转储直接ok</p>

<p>动态转储导入数据库副本和项目日志，使用数据库故障恢复方法恢复</p>
</blockquote>

<p>2.装入相关的日志文件副本，REDO</p>

<h3>
<a id="具有检查点的恢复技术" class="anchor" href="#%E5%85%B7%E6%9C%89%E6%A3%80%E6%9F%A5%E7%82%B9%E7%9A%84%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>具有检查点的恢复技术</h3>

<p>检查点：统计备份时未提交的事务目录，这样以后用这个备份时就不用检索日志获得UNDO队列了</p>

<p><img src="10-3.png" alt="10-3"></p>

<p><img src="10-4.png" alt="10-4"></p>

<p>数据库镜像。。。。</p>

<h2>
<a id="第十一章并发控制" class="anchor" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>第十一章、并发控制</h2>

<p>【应该不是重点吧】</p>

<h4>
<a id="并发操作带来的不一致性" class="anchor" href="#%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E5%B8%A6%E6%9D%A5%E7%9A%84%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%A7" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>并发操作带来的不一致性</h4>

<blockquote>
<p>丢失修改</p>

<blockquote>
<p>两个事务并发修改，先改的会被覆盖</p>
</blockquote>

<p>不可重复读</p>

<blockquote>
<p>读数据后数据被更新</p>
</blockquote>

<p>读脏数据</p>

<blockquote>
<p>更新了读，读了后更新数据的事务被撤销</p>
</blockquote>
</blockquote>

<h3>
<a id="锁" class="anchor" href="#%E9%94%81" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>锁</h3>

<p>写锁：X</p>

<p>读锁：S</p>

<p>​ <img src="11-1.png" alt="读锁和写锁的相容性"></p>

<h3>
<a id="活锁和死锁" class="anchor" href="#%E6%B4%BB%E9%94%81%E5%92%8C%E6%AD%BB%E9%94%81" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>活锁和死锁</h3>

<h5>
<a id="活锁不断有人插队longrightarrow使用先来先服务" class="anchor" href="#%E6%B4%BB%E9%94%81%E4%B8%8D%E6%96%AD%E6%9C%89%E4%BA%BA%E6%8F%92%E9%98%9Flongrightarrow%E4%BD%BF%E7%94%A8%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>活锁：不断有人插队$\longrightarrow$使用先来先服务</h5>

<h5>
<a id="死锁连个环longrightarrow" class="anchor" href="#%E6%AD%BB%E9%94%81%E8%BF%9E%E4%B8%AA%E7%8E%AFlongrightarrow" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>死锁：连个环$\longrightarrow$</h5>

<p>预防死锁</p>

<blockquote>
<p>一次封锁法</p>

<p>顺序封锁法</p>
</blockquote>

<p>诊断和解除</p>

<blockquote>
<p>超时法</p>

<p><strong>等待图法</strong>【合理】</p>
</blockquote>

<h3>
<a id="并发调度的可串行性" class="anchor" href="#%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6%E7%9A%84%E5%8F%AF%E4%B8%B2%E8%A1%8C%E6%80%A7" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>并发调度的可串行性</h3>

<p>如果并发的结果和某种顺序的串行结果一致，则并发时没有出现错误的</p>

<h3>
<a id="两段锁协议" class="anchor" href="#%E4%B8%A4%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>两段锁协议</h3>

<p>一致申$\longrightarrow$一致放</p>

<p>分为：扩展阶段和收缩阶段</p>

<h3>
<a id="封锁粒度" class="anchor" href="#%E5%B0%81%E9%94%81%E7%B2%92%E5%BA%A6" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>封锁粒度</h3>

<p>封锁的对象大小</p>

<p>粒度$\uparrow      \longrightarrow     $锁的数量$\uparrow$，系统开销$\uparrow$，并发程度$\uparrow$</p>

<p>n在多粒度封锁中一个数据对象可能以两种方式封锁：</p>

<p>显式封锁: 直接加到数据对象上的封锁</p>

<p>隐式封锁: 由于其上级结点加锁而使该数据对象加上了锁</p>

      <footer class="site-footer">

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
